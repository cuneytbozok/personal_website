---
import BaseLayout from '../layouts/BaseLayout.astro';
import Nav from './Nav.astro';
import SocialRail from './SocialRail.astro';
import EmailRail from './EmailRail.astro';
import Footer from './Footer.astro';
import Menu from './Menu.astro';
import Loader from './Loader.astro';

interface Props {
  title?: string;
  description?: string;
}

const { title, description } = Astro.props;
---

<BaseLayout title={title} description={description}>
  <Loader />
  <a href="#content" class="skip-to-content">
    Skip to Content
  </a>

  <Nav />
  <SocialRail />
  <Menu />

  <main
    id="content"
    class="scroll-sections min-h-screen px-6"
    tabindex="-1"
  >
    <slot />
  </main>

  <Footer />
  <EmailRail />
</BaseLayout>

<script type="module">
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)');
  const coarsePointer = window.matchMedia('(pointer: coarse)');
  const sections = document.querySelectorAll('.section-fade');
  const nav = document.querySelector('nav[aria-label="Main navigation"]');
  let updateParallax = () => {};

  if (prefersReduced.matches || coarsePointer.matches || sections.length === 0) {
    sections.forEach((section) => section.classList.add('is-visible'));
  } else {
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        entry.target.classList.toggle('is-visible', entry.isIntersecting);
      });
    },
    {
      threshold: 0.25,
      rootMargin: '0px 0px -10% 0px',
    }
  );

  sections.forEach((section) => observer.observe(section));

  let rafId = 0;
  updateParallax = () => {
    const viewportHeight = window.innerHeight || 1;
    const viewportCenter = viewportHeight / 2;

    sections.forEach((section) => {
      const rect = section.getBoundingClientRect();
      const sectionCenter = rect.top + rect.height / 2;
      const distance = (sectionCenter - viewportCenter) / viewportHeight;
      const clamped = Math.max(-1, Math.min(1, distance));
      const parallax = clamped * -90;
      const scale = 1 - Math.min(0.1, Math.abs(clamped) * 0.07);

      section.style.setProperty('--section-parallax', `${parallax}px`);
      section.style.setProperty('--section-scale', `${scale}`);
    });
  };

  const scheduleParallax = () => {
    if (rafId) return;
    rafId = window.requestAnimationFrame(() => {
      rafId = 0;
      updateParallax();
    });
  };

  window.addEventListener('scroll', scheduleParallax, { passive: true });
  window.addEventListener('resize', scheduleParallax);
  updateParallax();
  }

  const getNavOffset = () => nav?.getBoundingClientRect().height ?? 0;

  const getElementTop = (element) => {
    let top = 0;
    let node = element;

    while (node) {
      top += node.offsetTop;
      node = node.offsetParent;
    }

    return top;
  };

  const disableSnap = () => {
    const html = document.documentElement;
    const prev = html.style.scrollSnapType;
    html.style.scrollSnapType = 'none';
    return () => {
      html.style.scrollSnapType = prev;
    };
  };

  const waitForScrollEnd = (callback) => {
    let lastY = window.scrollY;
    let sameCount = 0;

    const tick = () => {
      const y = window.scrollY;
      if (Math.abs(y - lastY) < 1) {
        sameCount += 1;
      } else {
        sameCount = 0;
        lastY = y;
      }

      if (sameCount >= 4) {
        callback();
        return;
      }

      window.requestAnimationFrame(tick);
    };

    window.requestAnimationFrame(tick);
  };

  const scrollToHash = (hash, behavior = 'smooth') => {
    if (!hash) return;
    const target = document.querySelector(hash);
    if (!target) return;

    const offset = getNavOffset();
    const targetTop = getElementTop(target) - offset;
    const restoreSnap = disableSnap();

    window.scrollTo({
      top: Math.max(targetTop, 0),
      behavior: prefersReduced.matches ? 'auto' : behavior,
    });

    waitForScrollEnd(() => {
      restoreSnap();
      updateParallax();
    });
  };

  const shouldHandleLink = (link) => {
    const url = new URL(link.href, window.location.href);
    if (url.origin !== window.location.origin) return false;
    if (url.pathname !== window.location.pathname) return false;
    return Boolean(url.hash);
  };

  const handleAnchorClick = (event) => {
    const link = event.currentTarget;
    if (!(link instanceof HTMLAnchorElement)) return;
    if (!shouldHandleLink(link)) return;

    event.preventDefault();
    const { hash } = new URL(link.href, window.location.href);
    history.pushState(null, '', hash);
    scrollToHash(hash);
  };

  document.querySelectorAll('a[href*="#"]').forEach((link) => {
    if (!(link instanceof HTMLAnchorElement)) return;
    if (!shouldHandleLink(link)) return;
    link.addEventListener('click', handleAnchorClick);
  });

  window.addEventListener('load', () => {
    if (window.location.hash) {
      scrollToHash(window.location.hash, 'auto');
    }
  });

  window.addEventListener('popstate', () => {
    if (window.location.hash) {
      scrollToHash(window.location.hash, 'auto');
    }
  });

  window.addEventListener('hashchange', () => {
    if (window.location.hash) {
      scrollToHash(window.location.hash, 'auto');
    }
  });
</script>
